# Snapshot report for `test/lib/generator/struct.js`

The actual snapshot is saved in `struct.js.snap`.

Generated by [AVA](https://ava.li).

## structGenerator

> Snapshot 1

    `let TestStruct$TypeCache = null;␊
    const TestStruct$bonks = Symbol('bonks');␊
    const TestStruct$bonk = Symbol('bonk');␊
    const TestStruct$newbyte = Symbol('newbyte');␊
    const TestStruct$newshort = Symbol('newshort');␊
    const TestStruct$my_set = Symbol('my_set');␊
    const TestStruct$types = Symbol('types');␊
    export class TestStruct extends Struct {␊
      constructor(args) {␊
        super();␊
    ␊
        this[TestStruct$bonks] = null;␊
        this[TestStruct$bonk] = null;␊
        this[TestStruct$newbyte] = null;␊
        this[TestStruct$newshort] = 123;␊
        this[TestStruct$my_set] = null;␊
        this[TestStruct$types] = null;␊
    ␊
        if (args) {␊
          this.bonks = args.bonks;␊
          this.bonk = args.bonk;␊
          this.newbyte = args.newbyte;␊
          this.newshort = args.newshort;␊
          this.mySet = args.mySet;␊
          this.types = args.types;␊
        }␊
      }␊
    ␊
      static get Types() {␊
        if(TestStruct$TypeCache) return TestStruct$TypeCache;␊
        TestStruct$TypeCache = new Map();␊
         TestStruct$TypeCache.set(1, { name: 'bonks', customName: 'bonks', type: { name: 'list', type: Bonk } });␊
         TestStruct$TypeCache.set(2, { name: 'bonk', customName: 'bonk', type: Bonk });␊
         TestStruct$TypeCache.set(3, { name: 'newbyte', customName: 'newbyte', type: 'i8' });␊
         TestStruct$TypeCache.set(4, { name: 'newshort', customName: 'newshort', type: 'i16' });␊
         TestStruct$TypeCache.set(5, { name: 'my_set', customName: 'mySet', type: { name: 'set', type: Bonk } });␊
         TestStruct$TypeCache.set(6, { name: 'types', customName: 'types', type: { name: 'map', keyType: 'i32', valueType: { name: 'list', type: Numbers } } });␊
        return TestStruct$TypeCache;␊
      }␊
    ␊
      get bonks() { return this[TestStruct$bonks]; }␊
      set bonks(val) {␊
        if(val !== undefined) {␊
          this[TestStruct$bonks] = new TList(val, Bonk);␊
        }␊
      }␊
    ␊
      get bonk() { return this[TestStruct$bonk]; }␊
      set bonk(val) {␊
        if(val !== undefined) {␊
          if(val instanceof Bonk) {␊
            this[TestStruct$bonk] = val;␊
          } else {␊
            this[TestStruct$bonk] = new Bonk(val);␊
          }␊
        }␊
      }␊
    ␊
      get newbyte() { return this[TestStruct$newbyte]; }␊
      set newbyte(val) {␊
        if(val !== undefined) {␊
          this[TestStruct$newbyte] = val;␊
        }␊
      }␊
    ␊
      get newshort() { return this[TestStruct$newshort]; }␊
      set newshort(val) {␊
        if(val !== undefined) {␊
          this[TestStruct$newshort] = val;␊
        }␊
      }␊
    ␊
      get mySet() { return this[TestStruct$my_set]; }␊
      set mySet(val) {␊
        if(val !== undefined) {␊
          this[TestStruct$my_set] = new TSet(val, Bonk);␊
        }␊
      }␊
    ␊
      get types() { return this[TestStruct$types]; }␊
      set types(val) {␊
        if(val !== undefined) {␊
          this[TestStruct$types] = new TMap(val, 'i32', { name: 'list', type: Numbers });␊
        }␊
      }␊
    }␊
    `

> Snapshot 2

    `let TestStruct$TypeCache = null;␊
    const TestStruct$bonks = Symbol('bonks');␊
    const TestStruct$bonk = Symbol('bonk');␊
    const TestStruct$newbyte = Symbol('newbyte');␊
    const TestStruct$newshort = Symbol('newshort');␊
    const TestStruct$my_set = Symbol('my_set');␊
    const TestStruct$types = Symbol('types');␊
    class TestStruct extends Struct {␊
      constructor(args) {␊
        super();␊
    ␊
        this[TestStruct$bonks] = null;␊
        this[TestStruct$bonk] = null;␊
        this[TestStruct$newbyte] = null;␊
        this[TestStruct$newshort] = 123;␊
        this[TestStruct$my_set] = null;␊
        this[TestStruct$types] = null;␊
    ␊
        if (args) {␊
          this.BONKS = args.BONKS;␊
          this.BONK = args.BONK;␊
          this.NEWBYTE = args.NEWBYTE;␊
          this.NEWSHORT = args.NEWSHORT;␊
          this.MY_SET = args.MY_SET;␊
          this.TYPES = args.TYPES;␊
        }␊
      }␊
    ␊
      static get Types() {␊
        if(TestStruct$TypeCache) return TestStruct$TypeCache;␊
        TestStruct$TypeCache = new Map();␊
         TestStruct$TypeCache.set(1, { name: 'bonks', customName: 'BONKS', type: { name: 'list', type: Bonk } });␊
         TestStruct$TypeCache.set(2, { name: 'bonk', customName: 'BONK', type: Bonk });␊
         TestStruct$TypeCache.set(3, { name: 'newbyte', customName: 'NEWBYTE', type: 'i8' });␊
         TestStruct$TypeCache.set(4, { name: 'newshort', customName: 'NEWSHORT', type: 'i16' });␊
         TestStruct$TypeCache.set(5, { name: 'my_set', customName: 'MY_SET', type: { name: 'set', type: Bonk } });␊
         TestStruct$TypeCache.set(6, { name: 'types', customName: 'TYPES', type: { name: 'map', keyType: 'i32', valueType: { name: 'list', type: Numbers } } });␊
        return TestStruct$TypeCache;␊
      }␊
    ␊
      get BONKS() { return this[TestStruct$bonks]; }␊
      set BONKS(val) {␊
        if(val !== undefined) {␊
          this[TestStruct$bonks] = new TList(val, Bonk);␊
        }␊
      }␊
    ␊
      get BONK() { return this[TestStruct$bonk]; }␊
      set BONK(val) {␊
        if(val !== undefined) {␊
          if(val instanceof Bonk) {␊
            this[TestStruct$bonk] = val;␊
          } else {␊
            this[TestStruct$bonk] = new Bonk(val);␊
          }␊
        }␊
      }␊
    ␊
      get NEWBYTE() { return this[TestStruct$newbyte]; }␊
      set NEWBYTE(val) {␊
        if(val !== undefined) {␊
          this[TestStruct$newbyte] = val;␊
        }␊
      }␊
    ␊
      get NEWSHORT() { return this[TestStruct$newshort]; }␊
      set NEWSHORT(val) {␊
        if(val !== undefined) {␊
          this[TestStruct$newshort] = val;␊
        }␊
      }␊
    ␊
      get MY_SET() { return this[TestStruct$my_set]; }␊
      set MY_SET(val) {␊
        if(val !== undefined) {␊
          this[TestStruct$my_set] = new TSet(val, Bonk);␊
        }␊
      }␊
    ␊
      get TYPES() { return this[TestStruct$types]; }␊
      set TYPES(val) {␊
        if(val !== undefined) {␊
          this[TestStruct$types] = new TMap(val, 'i32', { name: 'list', type: Numbers });␊
        }␊
      }␊
    }␊
    exports.TestStruct = TestStruct;␊
    `

> Snapshot 3

    `let TestStruct$TypeCache = null;␊
    const TestStruct$bonks = Symbol('bonks');␊
    const TestStruct$bonk = Symbol('bonk');␊
    const TestStruct$newbyte = Symbol('newbyte');␊
    const TestStruct$newshort = Symbol('newshort');␊
    const TestStruct$my_set = Symbol('my_set');␊
    const TestStruct$types = Symbol('types');␊
    class TestStruct extends Struct {␊
      constructor(args) {␊
        super();␊
    ␊
        this[TestStruct$bonks] = null;␊
        this[TestStruct$bonk] = null;␊
        this[TestStruct$newbyte] = null;␊
        this[TestStruct$newshort] = 123;␊
        this[TestStruct$my_set] = null;␊
        this[TestStruct$types] = null;␊
    ␊
        if (args) {␊
          this.bonks = args.bonks;␊
          this.bonk = args.bonk;␊
          this.newbyte = args.newbyte;␊
          this.newshort = args.newshort;␊
          this.my_set = args.my_set;␊
          this.types = args.types;␊
        }␊
      }␊
    ␊
      static get Types() {␊
        if(TestStruct$TypeCache) return TestStruct$TypeCache;␊
        TestStruct$TypeCache = new Map();␊
         TestStruct$TypeCache.set(1, { name: 'bonks', customName: 'bonks', type: { name: 'list', type: Bonk } });␊
         TestStruct$TypeCache.set(2, { name: 'bonk', customName: 'bonk', type: Bonk });␊
         TestStruct$TypeCache.set(3, { name: 'newbyte', customName: 'newbyte', type: 'i8' });␊
         TestStruct$TypeCache.set(4, { name: 'newshort', customName: 'newshort', type: 'i16' });␊
         TestStruct$TypeCache.set(5, { name: 'my_set', customName: 'my_set', type: { name: 'set', type: Bonk } });␊
         TestStruct$TypeCache.set(6, { name: 'types', customName: 'types', type: { name: 'map', keyType: 'i32', valueType: { name: 'list', type: Numbers } } });␊
        return TestStruct$TypeCache;␊
      }␊
    ␊
      get bonks() { return this[TestStruct$bonks]; }␊
      set bonks(val) {␊
        if(val !== undefined) {␊
          this[TestStruct$bonks] = new TList(val, Bonk);␊
        }␊
      }␊
    ␊
      get bonk() { return this[TestStruct$bonk]; }␊
      set bonk(val) {␊
        if(val !== undefined) {␊
          if(val instanceof Bonk) {␊
            this[TestStruct$bonk] = val;␊
          } else {␊
            this[TestStruct$bonk] = new Bonk(val);␊
          }␊
        }␊
      }␊
    ␊
      get newbyte() { return this[TestStruct$newbyte]; }␊
      set newbyte(val) {␊
        if(val !== undefined) {␊
          this[TestStruct$newbyte] = val;␊
        }␊
      }␊
    ␊
      get newshort() { return this[TestStruct$newshort]; }␊
      set newshort(val) {␊
        if(val !== undefined) {␊
          this[TestStruct$newshort] = val;␊
        }␊
      }␊
    ␊
      get my_set() { return this[TestStruct$my_set]; }␊
      set my_set(val) {␊
        if(val !== undefined) {␊
          this[TestStruct$my_set] = new TSet(val, Bonk);␊
        }␊
      }␊
    ␊
      get types() { return this[TestStruct$types]; }␊
      set types(val) {␊
        if(val !== undefined) {␊
          this[TestStruct$types] = new TMap(val, 'i32', { name: 'list', type: Numbers });␊
        }␊
      }␊
    }␊
    exports.TestStruct = TestStruct;␊
    `
