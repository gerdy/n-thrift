# Snapshot report for `test/lib/generator/service.js`

The actual snapshot is saved in `service.js.snap`.

Generated by [AVA](https://ava.li).

## clientGenerator

> Snapshot 1

    `␊
    let Test$TypeCache = null;␊
    ␊
    export class TestClient extends Client {␊
    ␊
      testVoid() {␊
        const args = {  };␊
        return this.send('testVoid', args)␊
      }␊
    ␊
      testString(my_age) {␊
        const args = { my_age };␊
        return this.send('testString', args)␊
      }␊
    ␊
      testString2(my_age, my_Name) {␊
        const args = { my_age, my_Name };␊
        return this.send('testString2', args)␊
      }␊
    ␊
      static get Types() {␊
        if(Test$TypeCache) return Test$TypeCache;␊
        Test$TypeCache = new Map();␊
        Test$TypeCache.set('testVoid', {␊
          customName: testVoid,␊
          argumentType: Test$testVoid$Args,␊
          resultType: Test$testVoid$Result,␊
          oneway: false␊
        });␊
        Test$TypeCache.set('testString', {␊
          customName: testString,␊
          argumentType: Test$testString$Args,␊
          resultType: Test$testString$Result,␊
          oneway: true␊
        });␊
        Test$TypeCache.set('testString2', {␊
          customName: testString2,␊
          argumentType: Test$testString2$Args,␊
          resultType: Test$testString2$Result,␊
          oneway: true␊
        });␊
        return Test$TypeCache;␊
      }␊
    }␊
    ␊
    `

> Snapshot 2

    `␊
    let LegacyTest$TypeCache = null;␊
    ␊
    class LegacyTestClient extends BaseClient {␊
    ␊
      testVoid() {␊
        const args = {  };␊
        return this.send('testVoid', args)␊
      }␊
    ␊
      testString(my_age) {␊
        const args = { my_age };␊
        return this.send('testString', args)␊
      }␊
    ␊
      testString2(my_age, my_Name) {␊
        const args = { my_age, my_Name };␊
        return this.send('testString2', args)␊
      }␊
    ␊
      static get Types() {␊
        if(LegacyTest$TypeCache) return LegacyTest$TypeCache;␊
        LegacyTest$TypeCache = new Map();␊
        LegacyTest$TypeCache.set('testVoid', {␊
          customName: testVoid,␊
          argumentType: LegacyTest$testVoid$Args,␊
          resultType: LegacyTest$testVoid$Result,␊
          oneway: false␊
        });␊
        LegacyTest$TypeCache.set('testString', {␊
          customName: testString,␊
          argumentType: LegacyTest$testString$Args,␊
          resultType: LegacyTest$testString$Result,␊
          oneway: true␊
        });␊
        LegacyTest$TypeCache.set('testString2', {␊
          customName: testString2,␊
          argumentType: LegacyTest$testString2$Args,␊
          resultType: LegacyTest$testString2$Result,␊
          oneway: true␊
        });␊
        return LegacyTest$TypeCache;␊
      }␊
    }␊
    exports.LegacyTestClient = LegacyTestClient␊
    exports.Client = LegacyTestClient;␊
    `

## resultGenerator

> Snapshot 1

    `␊
    let MyTest$testMultiException$Result$TypeCache = null;␊
    const MyTest$testMultiException$Result$success = Symbol('success');␊
    const MyTest$testMultiException$Result$err1 = Symbol('err1');␊
    const MyTest$testMultiException$Result$err2 = Symbol('err2');␊
    const MyTest$testMultiException$Result$err2 = Symbol('err2');␊
    ␊
    export class MyTest$testMultiException$Result extends Struct {␊
      constructor(argument) {␊
        super();␊
        this[MyTest$testMultiException$Result$success] = null;␊
        this[MyTest$testMultiException$Result$err1] = null;␊
        this[MyTest$testMultiException$Result$err2] = null;␊
        this[MyTest$testMultiException$Result$err2] = null;␊
        if (argument) {␊
          if(argument instanceof Xception) {␊
            this.err1 = argument;␊
            return;␊
          }␊
          if(argument instanceof Xception2) {␊
            this.err2 = argument;␊
            return;␊
          }␊
          if(argument instanceof Xception2) {␊
            this.err2 = argument;␊
            return;␊
          }␊
          this.success = argument; ␊
        }␊
      }␊
    ␊
      get success() { return this[MyTest$testMultiException$Result$success]; }␊
      set success(val) {␊
        if(val !== undefined) {␊
          this[$success] = new TMap(val, 'i32', { type: TList, keyType: Numbers });␊
      }␊
    ␊
      get err1() { return this[MyTest$testMultiException$Result$err1]; }␊
      set err1(val) {␊
        if(val !== undefined) {␊
          if(val instanceof Xception) {␊
            this[$err1] = val;␊
          } else {␊
            this[$err1] = new Xception(val);␊
          }␊
        }␊
      }␊
    ␊
      get err2() { return this[MyTest$testMultiException$Result$err2]; }␊
      set err2(val) {␊
        if(val !== undefined) {␊
          if(val instanceof Xception2) {␊
            this[$err2] = val;␊
          } else {␊
            this[$err2] = new Xception2(val);␊
          }␊
        }␊
      }␊
    ␊
      get err2() { return this[MyTest$testMultiException$Result$err2]; }␊
      set err2(val) {␊
        if(val !== undefined) {␊
          if(val instanceof Xception2) {␊
            this[$err2] = val;␊
          } else {␊
            this[$err2] = new Xception2(val);␊
          }␊
        }␊
      }␊
    ␊
      static get Types() {␊
        if(MyTest$testMultiException$Result$TypeCache) return MyTest$testMultiException$Result$TypeCache;␊
        MyTest$testMultiException$Result$TypeCache = new Map();␊
        MyTest$testMultiException$Result$TypeCache.set(0, { name: 'success', customName: 'success', type: { type: TMap, keyType: 'i32', valueType: { type: TList, keyType: Numbers } } });␊
        MyTest$testMultiException$Result$TypeCache.set(1, { name: 'err1', customName: 'err1', type: Xception });␊
        MyTest$testMultiException$Result$TypeCache.set(2, { name: 'err2', customName: 'err2', type: Xception2 });␊
        MyTest$testMultiException$Result$TypeCache.set(3, { name: 'err2', customName: 'err2', type: Xception2 });␊
        return MyTest$testMultiException$Result$TypeCache;␊
      }␊
    }␊
    `

> Snapshot 2

    `␊
    let MyTest$testMultiException$Result$TypeCache = null;␊
    const MyTest$testMultiException$Result$success = Symbol('success');␊
    ␊
    class MyTest$testMultiException$Result extends Struct {␊
      constructor(argument) {␊
        super();␊
        this[MyTest$testMultiException$Result$success] = null;␊
        if (argument) {␊
          this.success = argument; ␊
        }␊
      }␊
    ␊
      get success() { return this[MyTest$testMultiException$Result$success]; }␊
      set success(val) {␊
        if(val !== undefined) {␊
          this[$success] = val;␊
      }␊
    ␊
      static get Types() {␊
        if(MyTest$testMultiException$Result$TypeCache) return MyTest$testMultiException$Result$TypeCache;␊
        MyTest$testMultiException$Result$TypeCache = new Map();␊
        MyTest$testMultiException$Result$TypeCache.set(0, { name: 'success', customName: 'success', type: 'string' });␊
        return MyTest$testMultiException$Result$TypeCache;␊
      }␊
    }␊
    exports.MyTest$testMultiException$Result = MyTest$testMultiException$Result;␊
    `

> Snapshot 3

    `␊
    let MyTest$testMultiException$Result$TypeCache = null;␊
    const MyTest$testMultiException$Result$err1 = Symbol('err1');␊
    ␊
    class MyTest$testMultiException$Result extends Struct {␊
      constructor(argument) {␊
        super();␊
        this[MyTest$testMultiException$Result$err1] = null;␊
        if (argument) {␊
          if(argument instanceof Xception) {␊
            this.err1 = argument;␊
            return;␊
          }␊
        }␊
      }␊
    ␊
      get err1() { return this[MyTest$testMultiException$Result$err1]; }␊
      set err1(val) {␊
        if(val !== undefined) {␊
          if(val instanceof Xception) {␊
            this[$err1] = val;␊
          } else {␊
            this[$err1] = new Xception(val);␊
          }␊
        }␊
      }␊
    ␊
      static get Types() {␊
        if(MyTest$testMultiException$Result$TypeCache) return MyTest$testMultiException$Result$TypeCache;␊
        MyTest$testMultiException$Result$TypeCache = new Map();␊
        MyTest$testMultiException$Result$TypeCache.set(1, { name: 'err1', customName: 'err1', type: Xception });␊
        return MyTest$testMultiException$Result$TypeCache;␊
      }␊
    }␊
    exports.MyTest$testMultiException$Result = MyTest$testMultiException$Result;␊
    `

> Snapshot 4

    `␊
    let MyTest$testMultiException$Result$TypeCache = null;␊
    const MyTest$testMultiException$Result$success = Symbol('success');␊
    ␊
    class MyTest$testMultiException$Result extends Struct {␊
      constructor(argument) {␊
        super();␊
        this[MyTest$testMultiException$Result$success] = null;␊
        if (argument) {␊
          this.success = argument; ␊
        }␊
      }␊
    ␊
      get success() { return this[MyTest$testMultiException$Result$success]; }␊
      set success(val) {␊
        if(val !== undefined) {␊
          this[$success] = new TSet(val, 'string');␊
      }␊
    ␊
      static get Types() {␊
        if(MyTest$testMultiException$Result$TypeCache) return MyTest$testMultiException$Result$TypeCache;␊
        MyTest$testMultiException$Result$TypeCache = new Map();␊
        MyTest$testMultiException$Result$TypeCache.set(0, { name: 'success', customName: 'success', type: { type: TSet, keyType: 'string' } });␊
        return MyTest$testMultiException$Result$TypeCache;␊
      }␊
    }␊
    exports.MyTest$testMultiException$Result = MyTest$testMultiException$Result;␊
    `

## serverGenerator

> Snapshot 1

    `␊
    ␊
    export class TestServer extends Server {␊
      constructor() {␊
        super(false);␊
      }␊
    ␊
      testVoid() {␊
        throw new Error('"Test.testVoid" is not implemented');␊
      }␊
    ␊
      testString(my_age) {␊
        throw new Error('"Test.testString" is not implemented');␊
      }␊
    ␊
      testString2(my_age, my_Name) {␊
        throw new Error('"Test.testString2" is not implemented');␊
      }␊
    ␊
      static get Types() {␊
        if(Test$TypeCache) return Test$TypeCache;␊
        Test$TypeCache = new Map();␊
        Test$TypeCache.set('testVoid', {␊
          customName: testVoid,␊
          argumentType: Test$testVoid$Args,␊
          resultType: Test$testVoid$Result,␊
          oneway: false␊
        });␊
        Test$TypeCache.set('testString', {␊
          customName: testString,␊
          argumentType: Test$testString$Args,␊
          resultType: Test$testString$Result,␊
          oneway: true␊
        });␊
        Test$TypeCache.set('testString2', {␊
          customName: testString2,␊
          argumentType: Test$testString2$Args,␊
          resultType: Test$testString2$Result,␊
          oneway: true␊
        });␊
        return Test$TypeCache;␊
      }␊
    }␊
    ␊
    `

> Snapshot 2

    `␊
    const LegacyTest$handler = Symbol('handler');␊
    ␊
    class LegacyTestServer extends BaseServer {␊
      constructor(handler) {␊
        super(true);␊
        this[$handler] = handler || {};␊
      }␊
    ␊
      testVoid() {␊
        if (typeof this[LegacyTest$handler].testVoid !== 'function') {␊
          throw new Error('"LegacyTest.testVoid" is not implemented');␊
        }␊
        return new Promise((resolve, reject) => {␊
          this[LegacyTest$handler].testVoid((error, result) => {␊
            if (error) return reject(error);␊
            return resolve(result);␊
          });␊
        });␊
      }␊
    ␊
      testString(my_age) {␊
        if (typeof this[LegacyTest$handler].testString !== 'function') {␊
          throw new Error('"LegacyTest.testString" is not implemented');␊
        }␊
        return new Promise((resolve, reject) => {␊
          this[LegacyTest$handler].testString(my_age, (error, result) => {␊
            if (error) return reject(error);␊
            return resolve(result);␊
          });␊
        });␊
      }␊
    ␊
      testString2(my_age, my_Name) {␊
        if (typeof this[LegacyTest$handler].testString2 !== 'function') {␊
          throw new Error('"LegacyTest.testString2" is not implemented');␊
        }␊
        return new Promise((resolve, reject) => {␊
          this[LegacyTest$handler].testString2(my_age, my_Name, (error, result) => {␊
            if (error) return reject(error);␊
            return resolve(result);␊
          });␊
        });␊
      }␊
    ␊
      static get Types() {␊
        if(LegacyTest$TypeCache) return LegacyTest$TypeCache;␊
        LegacyTest$TypeCache = new Map();␊
        LegacyTest$TypeCache.set('testVoid', {␊
          customName: testVoid,␊
          argumentType: LegacyTest$testVoid$Args,␊
          resultType: LegacyTest$testVoid$Result,␊
          oneway: false␊
        });␊
        LegacyTest$TypeCache.set('testString', {␊
          customName: testString,␊
          argumentType: LegacyTest$testString$Args,␊
          resultType: LegacyTest$testString$Result,␊
          oneway: true␊
        });␊
        LegacyTest$TypeCache.set('testString2', {␊
          customName: testString2,␊
          argumentType: LegacyTest$testString2$Args,␊
          resultType: LegacyTest$testString2$Result,␊
          oneway: true␊
        });␊
        return LegacyTest$TypeCache;␊
      }␊
    }␊
    exports.LegacyTestServer = LegacyTestServer␊
    exports.Processor = LegacyTestServer;␊
    `

## serviceGenerator

> Snapshot 1

    `␊
    let Test$blahBlah$Args$TypeCache = null;␊
    ␊
    export class Test$blahBlah$Args extends Struct {␊
      constructor(args) {␊
        ␊
        super();␊
        if (args) {␊
        }␊
      }␊
    ␊
      static get Types() {␊
        if(Test$blahBlah$Args$TypeCache) return Test$blahBlah$Args$TypeCache;␊
        Test$blahBlah$Args$TypeCache = new Map();␊
        return Test$blahBlah$Args$TypeCache;␊
      } ␊
    }␊
    ␊
    ␊
    let Test$secondtestString$Args$TypeCache = null;␊
    const Test$secondtestString$Args$my_thing = Symbol('my_thing');␊
    ␊
    export class Test$secondtestString$Args extends Struct {␊
      constructor(args) {␊
        ␊
        super();␊
        this[Test$secondtestString$Args$my_thing] = null;␊
        if (args) {␊
          this.myThing = args.myThing;␊
        }␊
      }␊
    ␊
      get myThing() { return this[Test$secondtestString$Args$my_thing]; }␊
      set myThing(val) {␊
        if(val !== undefined) {␊
          this[Test$secondtestString$Args$my_thing] = val;␊
        }␊
      }␊
    ␊
      static get Types() {␊
        if(Test$secondtestString$Args$TypeCache) return Test$secondtestString$Args$TypeCache;␊
        Test$secondtestString$Args$TypeCache = new Map();␊
         Test$secondtestString$Args$TypeCache.set(1, { name: 'my_thing', customName: 'myThing', type: 'string' });␊
        return Test$secondtestString$Args$TypeCache;␊
      } ␊
    }␊
    ␊
    ␊
    let Test$blahBlah$Result$TypeCache = null;␊
    ␊
    export class Test$blahBlah$Result extends Struct {␊
      constructor(argument) {␊
        super();␊
        if (argument) {␊
        }␊
      }␊
    ␊
      static get Types() {␊
        if(Test$blahBlah$Result$TypeCache) return Test$blahBlah$Result$TypeCache;␊
        Test$blahBlah$Result$TypeCache = new Map();␊
        return Test$blahBlah$Result$TypeCache;␊
      }␊
    }␊
    ␊
    ␊
    let Test$secondtestString$Result$TypeCache = null;␊
    const Test$secondtestString$Result$success = Symbol('success');␊
    const Test$secondtestString$Result$my_thing = Symbol('my_thing');␊
    ␊
    export class Test$secondtestString$Result extends Struct {␊
      constructor(argument) {␊
        super();␊
        this[Test$secondtestString$Result$success] = null;␊
        this[Test$secondtestString$Result$my_thing] = null;␊
        if (argument) {␊
          if(argument instanceof string) {␊
            this.my_thing = argument;␊
            return;␊
          }␊
          this.success = argument; ␊
        }␊
      }␊
    ␊
      get success() { return this[Test$secondtestString$Result$success]; }␊
      set success(val) {␊
        if(val !== undefined) {␊
          this[$success] = val;␊
      }␊
    ␊
      get my_thing() { return this[Test$secondtestString$Result$my_thing]; }␊
      set my_thing(val) {␊
        if(val !== undefined) {␊
          if(val instanceof string) {␊
            this[$my_thing] = val;␊
          } else {␊
            this[$my_thing] = new string(val);␊
          }␊
        }␊
      }␊
    ␊
      static get Types() {␊
        if(Test$secondtestString$Result$TypeCache) return Test$secondtestString$Result$TypeCache;␊
        Test$secondtestString$Result$TypeCache = new Map();␊
        Test$secondtestString$Result$TypeCache.set(0, { name: 'success', customName: 'success', type: 'string' });␊
        Test$secondtestString$Result$TypeCache.set(1, { name: 'my_thing', customName: 'my_thing', type: 'string' });␊
        return Test$secondtestString$Result$TypeCache;␊
      }␊
    }␊
    ␊
    ␊
    let Test$TypeCache = null;␊
    ␊
    export class TestClient extends BaseClient {␊
    ␊
      blahBlah() {␊
        const args = {  };␊
        return this.send('blahBlah', args)␊
      }␊
    ␊
      secondtestString(myThing) {␊
        const args = { myThing };␊
        return this.send('secondtestString', args)␊
      }␊
    ␊
      static get Types() {␊
        if(Test$TypeCache) return Test$TypeCache;␊
        Test$TypeCache = new Map();␊
        Test$TypeCache.set('blahBlah', {␊
          customName: blahBlah,␊
          argumentType: Test$blahBlah$Args,␊
          resultType: Test$blahBlah$Result,␊
          oneway: false␊
        });␊
        Test$TypeCache.set('secondtestString', {␊
          customName: secondtestString,␊
          argumentType: Test$secondtestString$Args,␊
          resultType: Test$secondtestString$Result,␊
          oneway: false␊
        });␊
        return Test$TypeCache;␊
      }␊
    }␊
    ␊
    ␊
    ␊
    export class TestServer extends BaseServer {␊
      constructor() {␊
        super(false);␊
      }␊
    ␊
      blahBlah() {␊
        throw new Error('"Test.blahBlah" is not implemented');␊
      }␊
    ␊
      secondtestString(myThing) {␊
        throw new Error('"Test.secondtestString" is not implemented');␊
      }␊
    ␊
      static get Types() {␊
        if(Test$TypeCache) return Test$TypeCache;␊
        Test$TypeCache = new Map();␊
        Test$TypeCache.set('blahBlah', {␊
          customName: blahBlah,␊
          argumentType: Test$blahBlah$Args,␊
          resultType: Test$blahBlah$Result,␊
          oneway: false␊
        });␊
        Test$TypeCache.set('secondtestString', {␊
          customName: secondtestString,␊
          argumentType: Test$secondtestString$Args,␊
          resultType: Test$secondtestString$Result,␊
          oneway: false␊
        });␊
        return Test$TypeCache;␊
      }␊
    }␊
    ␊
    `

> Snapshot 2

    `␊
    let Test$blahBlah$Args$TypeCache = null;␊
    ␊
    class Test$blahBlah$Args extends Struct {␊
      constructor(args) {␊
        ␊
        super();␊
        if (args) {␊
        }␊
      }␊
    ␊
      static get Types() {␊
        if(Test$blahBlah$Args$TypeCache) return Test$blahBlah$Args$TypeCache;␊
        Test$blahBlah$Args$TypeCache = new Map();␊
        return Test$blahBlah$Args$TypeCache;␊
      } ␊
    }␊
    exports.Test$blahBlah$Args = Test$blahBlah$Args;␊
    ␊
    ␊
    let Test$secondtestString$Args$TypeCache = null;␊
    const Test$secondtestString$Args$my_thing = Symbol('my_thing');␊
    ␊
    class Test$secondtestString$Args extends Struct {␊
      constructor(args) {␊
        ␊
        super();␊
        this[Test$secondtestString$Args$my_thing] = null;␊
        if (args) {␊
          this.my_thing = args.my_thing;␊
        }␊
      }␊
    ␊
      get my_thing() { return this[Test$secondtestString$Args$my_thing]; }␊
      set my_thing(val) {␊
        if(val !== undefined) {␊
          this[Test$secondtestString$Args$my_thing] = val;␊
        }␊
      }␊
    ␊
      static get Types() {␊
        if(Test$secondtestString$Args$TypeCache) return Test$secondtestString$Args$TypeCache;␊
        Test$secondtestString$Args$TypeCache = new Map();␊
         Test$secondtestString$Args$TypeCache.set(1, { name: 'my_thing', customName: 'my_thing', type: 'string' });␊
        return Test$secondtestString$Args$TypeCache;␊
      } ␊
    }␊
    exports.Test$secondtestString$Args = Test$secondtestString$Args;␊
    ␊
    ␊
    let Test$blahBlah$Result$TypeCache = null;␊
    ␊
    class Test$blahBlah$Result extends Struct {␊
      constructor(argument) {␊
        super();␊
        if (argument) {␊
        }␊
      }␊
    ␊
      static get Types() {␊
        if(Test$blahBlah$Result$TypeCache) return Test$blahBlah$Result$TypeCache;␊
        Test$blahBlah$Result$TypeCache = new Map();␊
        return Test$blahBlah$Result$TypeCache;␊
      }␊
    }␊
    exports.Test$blahBlah$Result = Test$blahBlah$Result;␊
    ␊
    ␊
    let Test$secondtestString$Result$TypeCache = null;␊
    const Test$secondtestString$Result$success = Symbol('success');␊
    const Test$secondtestString$Result$my_thing = Symbol('my_thing');␊
    ␊
    class Test$secondtestString$Result extends Struct {␊
      constructor(argument) {␊
        super();␊
        this[Test$secondtestString$Result$success] = null;␊
        this[Test$secondtestString$Result$my_thing] = null;␊
        if (argument) {␊
          if(argument instanceof string) {␊
            this.my_thing = argument;␊
            return;␊
          }␊
          this.success = argument; ␊
        }␊
      }␊
    ␊
      get success() { return this[Test$secondtestString$Result$success]; }␊
      set success(val) {␊
        if(val !== undefined) {␊
          this[$success] = val;␊
      }␊
    ␊
      get my_thing() { return this[Test$secondtestString$Result$my_thing]; }␊
      set my_thing(val) {␊
        if(val !== undefined) {␊
          if(val instanceof string) {␊
            this[$my_thing] = val;␊
          } else {␊
            this[$my_thing] = new string(val);␊
          }␊
        }␊
      }␊
    ␊
      static get Types() {␊
        if(Test$secondtestString$Result$TypeCache) return Test$secondtestString$Result$TypeCache;␊
        Test$secondtestString$Result$TypeCache = new Map();␊
        Test$secondtestString$Result$TypeCache.set(0, { name: 'success', customName: 'success', type: 'string' });␊
        Test$secondtestString$Result$TypeCache.set(1, { name: 'my_thing', customName: 'my_thing', type: 'string' });␊
        return Test$secondtestString$Result$TypeCache;␊
      }␊
    }␊
    exports.Test$secondtestString$Result = Test$secondtestString$Result;␊
    ␊
    ␊
    let Test$TypeCache = null;␊
    ␊
    class TestClient extends BaseClient {␊
    ␊
      blahBlah() {␊
        const args = {  };␊
        return this.send('blahBlah', args)␊
      }␊
    ␊
      secondtestString(my_thing) {␊
        const args = { my_thing };␊
        return this.send('secondtestString', args)␊
      }␊
    ␊
      static get Types() {␊
        if(Test$TypeCache) return Test$TypeCache;␊
        Test$TypeCache = new Map();␊
        Test$TypeCache.set('blahBlah', {␊
          customName: blahBlah,␊
          argumentType: Test$blahBlah$Args,␊
          resultType: Test$blahBlah$Result,␊
          oneway: false␊
        });␊
        Test$TypeCache.set('secondtestString', {␊
          customName: secondtestString,␊
          argumentType: Test$secondtestString$Args,␊
          resultType: Test$secondtestString$Result,␊
          oneway: false␊
        });␊
        return Test$TypeCache;␊
      }␊
    }␊
    exports.TestClient = TestClient␊
    ␊
    ␊
    class TestServer extends BaseServer {␊
      constructor() {␊
        super(false);␊
      }␊
    ␊
      blahBlah() {␊
        throw new Error('"Test.blahBlah" is not implemented');␊
      }␊
    ␊
      secondtestString(my_thing) {␊
        throw new Error('"Test.secondtestString" is not implemented');␊
      }␊
    ␊
      static get Types() {␊
        if(Test$TypeCache) return Test$TypeCache;␊
        Test$TypeCache = new Map();␊
        Test$TypeCache.set('blahBlah', {␊
          customName: blahBlah,␊
          argumentType: Test$blahBlah$Args,␊
          resultType: Test$blahBlah$Result,␊
          oneway: false␊
        });␊
        Test$TypeCache.set('secondtestString', {␊
          customName: secondtestString,␊
          argumentType: Test$secondtestString$Args,␊
          resultType: Test$secondtestString$Result,␊
          oneway: false␊
        });␊
        return Test$TypeCache;␊
      }␊
    }␊
    exports.TestServer = TestServer␊
    `
