# Snapshot report for `test/lib/generator/union.js`

The actual snapshot is saved in `union.js.snap`.

Generated by [AVA](https://ava.li).

## unionGenerator

> Snapshot 1

    `␊
    let TestUnion$TypeCache = null;␊
    const TestUnion$FieldName = Symbol('fieldName');␊
    const TestUnion$FieldValue = Symbol('fieldValue');␊
    ␊
    export class TestUnion extends Struct {␊
      constructor(args) {␊
        super();␊
        this[TestUnion$FieldName] = null;␊
        this[TestUnion$FieldValue] = null;␊
        if (args) {␊
          this.bonks = args.bonks;␊
          this.bonk = args.bonk;␊
          this.newbyte = args.newbyte;␊
          this.newshort = args.newshort;␊
          this.mySet = args.mySet;␊
          this.types = args.types;␊
        }␊
      }␊
    ␊
      get bonks() {␊
        if(this[TestUnion$FieldName] !== 'bonks') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set bonks(val) {␊
        this[TestUnion$FieldName] = 'bonks';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'list', typeClass: TList, valueType: { name: 'struct', typeClass: Bonk } }, 'bonks');␊
      }␊
    ␊
      get bonk() {␊
        if(this[TestUnion$FieldName] !== 'bonk') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set bonk(val) {␊
        this[TestUnion$FieldName] = 'bonk';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'struct', typeClass: Bonk }, 'bonk');␊
      }␊
    ␊
      get newbyte() {␊
        if(this[TestUnion$FieldName] !== 'newbyte') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set newbyte(val) {␊
        this[TestUnion$FieldName] = 'newbyte';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'i8', typeClass: null }, 'newbyte');␊
      }␊
    ␊
      get newshort() {␊
        if(this[TestUnion$FieldName] !== 'newshort') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set newshort(val) {␊
        this[TestUnion$FieldName] = 'newshort';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'i16', typeClass: null }, 'newshort');␊
      }␊
    ␊
      get mySet() {␊
        if(this[TestUnion$FieldName] !== 'mySet') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set mySet(val) {␊
        this[TestUnion$FieldName] = 'mySet';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'set', typeClass: TSet, valueType: { name: 'struct', typeClass: Bonk } }, 'mySet');␊
      }␊
    ␊
      get types() {␊
        if(this[TestUnion$FieldName] !== 'types') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set types(val) {␊
        this[TestUnion$FieldName] = 'types';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'map', typeClass: TMap, keyType: { name: 'i32', typeClass: null }, valueType: { name: 'list', typeClass: TList, valueType: { name: 'struct', typeClass: Numbers } } }, 'types');␊
      }␊
    ␊
      static get Types() {␊
        if(TestUnion$TypeCache) return TestUnion$TypeCache;␊
        TestUnion$TypeCache = new Map();␊
         TestUnion$TypeCache.set(1, { name: 'bonks', customName: 'bonks', type: { name: 'list', typeClass: TList, valueType: { name: 'struct', typeClass: Bonk } } });␊
         TestUnion$TypeCache.set(2, { name: 'bonk', customName: 'bonk', type: { name: 'struct', typeClass: Bonk } });␊
         TestUnion$TypeCache.set(3, { name: 'newbyte', customName: 'newbyte', type: { name: 'i8', typeClass: null } });␊
         TestUnion$TypeCache.set(4, { name: 'newshort', customName: 'newshort', type: { name: 'i16', typeClass: null } });␊
         TestUnion$TypeCache.set(5, { name: 'my_set', customName: 'mySet', type: { name: 'set', typeClass: TSet, valueType: { name: 'struct', typeClass: Bonk } } });␊
         TestUnion$TypeCache.set(6, { name: 'types', customName: 'types', type: { name: 'map', typeClass: TMap, keyType: { name: 'i32', typeClass: null }, valueType: { name: 'list', typeClass: TList, valueType: { name: 'struct', typeClass: Numbers } } } });␊
        return TestUnion$TypeCache;␊
      } ␊
    }␊
    `

> Snapshot 2

    `␊
    let TestUnion$TypeCache = null;␊
    const TestUnion$FieldName = Symbol('fieldName');␊
    const TestUnion$FieldValue = Symbol('fieldValue');␊
    ␊
    class TestUnion extends Struct {␊
      constructor(args) {␊
        super();␊
        this[TestUnion$FieldName] = null;␊
        this[TestUnion$FieldValue] = null;␊
        if (args) {␊
          this.BONKS = args.BONKS;␊
          this.BONK = args.BONK;␊
          this.NEWBYTE = args.NEWBYTE;␊
          this.NEWSHORT = args.NEWSHORT;␊
          this.MY_SET = args.MY_SET;␊
          this.TYPES = args.TYPES;␊
        }␊
      }␊
    ␊
      get BONKS() {␊
        if(this[TestUnion$FieldName] !== 'BONKS') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set BONKS(val) {␊
        this[TestUnion$FieldName] = 'BONKS';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'list', typeClass: TList, valueType: { name: 'struct', typeClass: Bonk } }, 'BONKS');␊
      }␊
    ␊
      get BONK() {␊
        if(this[TestUnion$FieldName] !== 'BONK') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set BONK(val) {␊
        this[TestUnion$FieldName] = 'BONK';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'struct', typeClass: Bonk }, 'BONK');␊
      }␊
    ␊
      get NEWBYTE() {␊
        if(this[TestUnion$FieldName] !== 'NEWBYTE') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set NEWBYTE(val) {␊
        this[TestUnion$FieldName] = 'NEWBYTE';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'i8', typeClass: null }, 'NEWBYTE');␊
      }␊
    ␊
      get NEWSHORT() {␊
        if(this[TestUnion$FieldName] !== 'NEWSHORT') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set NEWSHORT(val) {␊
        this[TestUnion$FieldName] = 'NEWSHORT';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'i16', typeClass: null }, 'NEWSHORT');␊
      }␊
    ␊
      get MY_SET() {␊
        if(this[TestUnion$FieldName] !== 'MY_SET') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set MY_SET(val) {␊
        this[TestUnion$FieldName] = 'MY_SET';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'set', typeClass: TSet, valueType: { name: 'struct', typeClass: Bonk } }, 'MY_SET');␊
      }␊
    ␊
      get TYPES() {␊
        if(this[TestUnion$FieldName] !== 'TYPES') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set TYPES(val) {␊
        this[TestUnion$FieldName] = 'TYPES';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'map', typeClass: TMap, keyType: { name: 'i32', typeClass: null }, valueType: { name: 'list', typeClass: TList, valueType: { name: 'struct', typeClass: Numbers } } }, 'TYPES');␊
      }␊
    ␊
      static get Types() {␊
        if(TestUnion$TypeCache) return TestUnion$TypeCache;␊
        TestUnion$TypeCache = new Map();␊
         TestUnion$TypeCache.set(1, { name: 'bonks', customName: 'BONKS', type: { name: 'list', typeClass: TList, valueType: { name: 'struct', typeClass: Bonk } } });␊
         TestUnion$TypeCache.set(2, { name: 'bonk', customName: 'BONK', type: { name: 'struct', typeClass: Bonk } });␊
         TestUnion$TypeCache.set(3, { name: 'newbyte', customName: 'NEWBYTE', type: { name: 'i8', typeClass: null } });␊
         TestUnion$TypeCache.set(4, { name: 'newshort', customName: 'NEWSHORT', type: { name: 'i16', typeClass: null } });␊
         TestUnion$TypeCache.set(5, { name: 'my_set', customName: 'MY_SET', type: { name: 'set', typeClass: TSet, valueType: { name: 'struct', typeClass: Bonk } } });␊
         TestUnion$TypeCache.set(6, { name: 'types', customName: 'TYPES', type: { name: 'map', typeClass: TMap, keyType: { name: 'i32', typeClass: null }, valueType: { name: 'list', typeClass: TList, valueType: { name: 'struct', typeClass: Numbers } } } });␊
        return TestUnion$TypeCache;␊
      } ␊
    }␊
    exports.TestUnion = TestUnion;␊
    `

> Snapshot 3

    `␊
    let TestUnion$TypeCache = null;␊
    const TestUnion$FieldName = Symbol('fieldName');␊
    const TestUnion$FieldValue = Symbol('fieldValue');␊
    ␊
    class TestUnion extends Struct {␊
      constructor(args) {␊
        super();␊
        this[TestUnion$FieldName] = null;␊
        this[TestUnion$FieldValue] = null;␊
        if (args) {␊
          this.bonks = args.bonks;␊
          this.bonk = args.bonk;␊
          this.newbyte = args.newbyte;␊
          this.newshort = args.newshort;␊
          this.my_set = args.my_set;␊
          this.types = args.types;␊
        }␊
      }␊
    ␊
      get bonks() {␊
        if(this[TestUnion$FieldName] !== 'bonks') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set bonks(val) {␊
        this[TestUnion$FieldName] = 'bonks';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'list', typeClass: TList, valueType: { name: 'struct', typeClass: Bonk } }, 'bonks');␊
      }␊
    ␊
      get bonk() {␊
        if(this[TestUnion$FieldName] !== 'bonk') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set bonk(val) {␊
        this[TestUnion$FieldName] = 'bonk';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'struct', typeClass: Bonk }, 'bonk');␊
      }␊
    ␊
      get newbyte() {␊
        if(this[TestUnion$FieldName] !== 'newbyte') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set newbyte(val) {␊
        this[TestUnion$FieldName] = 'newbyte';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'i8', typeClass: null }, 'newbyte');␊
      }␊
    ␊
      get newshort() {␊
        if(this[TestUnion$FieldName] !== 'newshort') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set newshort(val) {␊
        this[TestUnion$FieldName] = 'newshort';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'i16', typeClass: null }, 'newshort');␊
      }␊
    ␊
      get my_set() {␊
        if(this[TestUnion$FieldName] !== 'my_set') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set my_set(val) {␊
        this[TestUnion$FieldName] = 'my_set';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'set', typeClass: TSet, valueType: { name: 'struct', typeClass: Bonk } }, 'my_set');␊
      }␊
    ␊
      get types() {␊
        if(this[TestUnion$FieldName] !== 'types') return null;␊
        return this[TestUnion$FieldValue];␊
      }␊
      set types(val) {␊
        this[TestUnion$FieldName] = 'types';␊
        this[TestUnion$FieldValue] = this[convertToTypedValue](val, { name: 'map', typeClass: TMap, keyType: { name: 'i32', typeClass: null }, valueType: { name: 'list', typeClass: TList, valueType: { name: 'struct', typeClass: Numbers } } }, 'types');␊
      }␊
    ␊
      static get Types() {␊
        if(TestUnion$TypeCache) return TestUnion$TypeCache;␊
        TestUnion$TypeCache = new Map();␊
         TestUnion$TypeCache.set(1, { name: 'bonks', customName: 'bonks', type: { name: 'list', typeClass: TList, valueType: { name: 'struct', typeClass: Bonk } } });␊
         TestUnion$TypeCache.set(2, { name: 'bonk', customName: 'bonk', type: { name: 'struct', typeClass: Bonk } });␊
         TestUnion$TypeCache.set(3, { name: 'newbyte', customName: 'newbyte', type: { name: 'i8', typeClass: null } });␊
         TestUnion$TypeCache.set(4, { name: 'newshort', customName: 'newshort', type: { name: 'i16', typeClass: null } });␊
         TestUnion$TypeCache.set(5, { name: 'my_set', customName: 'my_set', type: { name: 'set', typeClass: TSet, valueType: { name: 'struct', typeClass: Bonk } } });␊
         TestUnion$TypeCache.set(6, { name: 'types', customName: 'types', type: { name: 'map', typeClass: TMap, keyType: { name: 'i32', typeClass: null }, valueType: { name: 'list', typeClass: TList, valueType: { name: 'struct', typeClass: Numbers } } } });␊
        return TestUnion$TypeCache;␊
      } ␊
    }␊
    exports.TestUnion = TestUnion;␊
    `
