# Snapshot report for `test/lib/generator/compiler/service.js`

The actual snapshot is saved in `service.js.snap`.

Generated by [AVA](https://ava.li).

## clientGenerator

> Snapshot 1

    `␊
    let Test$TypeCache = null;␊
    ␊
    export class TestClient extends TClient {␊
      testVoid() {␊
        const args = {  };␊
        return this[$send]('testVoid', args);␊
      }␊
    ␊
      testString(my_age) {␊
        const args = { my_age };␊
        return this[$send]('testString', args);␊
      }␊
    ␊
      testString2(my_age, my_Name) {␊
        const args = { my_age, my_Name };␊
        return this[$send]('testString2', args);␊
      }␊
    ␊
      static get Type() {␊
        if (Test$TypeCache) return Test$TypeCache;␊
        Test$TypeCache = new Map(super.constructor.Type);␊
        Test$TypeCache.set('testVoid', {␊
          customName: 'testVoid',␊
          argumentType: Test$testVoid$Args,␊
          resultType: Test$testVoid$Result,␊
          oneway: false␊
        });␊
        Test$TypeCache.set('testString', {␊
          customName: 'testString',␊
          argumentType: Test$testString$Args,␊
          resultType: Test$testString$Result,␊
          oneway: true␊
        });␊
        Test$TypeCache.set('testString2', {␊
          customName: 'testString2',␊
          argumentType: Test$testString2$Args,␊
          resultType: Test$testString2$Result,␊
          oneway: true␊
        });␊
        return Test$TypeCache;␊
      }␊
    }␊
    ;␊
    `

> Snapshot 2

    `␊
    let LegacyTest$TypeCache = null;␊
    ␊
    class LegacyTestClient extends BaseClient {␊
      testVoid() {␊
        const args = {  };␊
        return this[$send]('testVoid', args);␊
      }␊
    ␊
      testString(my_age) {␊
        const args = { my_age };␊
        return this[$send]('testString', args);␊
      }␊
    ␊
      testString2(my_age, my_Name) {␊
        const args = { my_age, my_Name };␊
        return this[$send]('testString2', args);␊
      }␊
    ␊
      static get Type() {␊
        if (LegacyTest$TypeCache) return LegacyTest$TypeCache;␊
        LegacyTest$TypeCache = new Map(super.constructor.Type);␊
        LegacyTest$TypeCache.set('testVoid', {␊
          customName: 'testVoid',␊
          argumentType: LegacyTest$testVoid$Args,␊
          resultType: LegacyTest$testVoid$Result,␊
          oneway: false␊
        });␊
        LegacyTest$TypeCache.set('testString', {␊
          customName: 'testString',␊
          argumentType: LegacyTest$testString$Args,␊
          resultType: LegacyTest$testString$Result,␊
          oneway: true␊
        });␊
        LegacyTest$TypeCache.set('testString2', {␊
          customName: 'testString2',␊
          argumentType: LegacyTest$testString2$Args,␊
          resultType: LegacyTest$testString2$Result,␊
          oneway: true␊
        });␊
        return LegacyTest$TypeCache;␊
      }␊
    }␊
    exports.LegacyTestClient = LegacyTestClient;␊
    `

## resultGenerator

> Snapshot 1

    `␊
    let Test$blahBlah$Result$TypeCache = null;␊
    ␊
    export class Test$blahBlah$Result extends Base {␊
      constructor(args) {␊
        super();␊
        if (args) {␊
        }␊
      }␊
    ␊
      static get Type() {␊
        if (Test$blahBlah$Result$TypeCache) return Test$blahBlah$Result$TypeCache;␊
        Test$blahBlah$Result$TypeCache = new Map();␊
        return Test$blahBlah$Result$TypeCache;␊
      }␊
    }␊
    ␊
    ␊
    let Test$secondtestString$Result$TypeCache = null;␊
    const Test$secondtestString$Result$success = Symbol('success');␊
    const Test$secondtestString$Result$err1 = Symbol('err1');␊
    ␊
    export class Test$secondtestString$Result extends Base {␊
      constructor(args) {␊
        super();␊
        this[Test$secondtestString$Result$success] = null;␊
        this[Test$secondtestString$Result$err1] = null;␊
        if (args) {␊
          this.success = args.success;␊
          this.err1 = args.err1;␊
        }␊
      }␊
    ␊
      get success() { return this[Test$secondtestString$Result$success]; }␊
      set success(val) {␊
        this[Test$secondtestString$Result$success] = this[$convertToTypedValue](val, { name: 'string', typeClass: null }, 'success');␊
      }␊
    ␊
      get err1() { return this[Test$secondtestString$Result$err1]; }␊
      set err1(val) {␊
        this[Test$secondtestString$Result$err1] = this[$convertToTypedValue](val, { name: 'struct', typeClass: Xception }, 'err1');␊
      }␊
    ␊
      static get Type() {␊
        if (Test$secondtestString$Result$TypeCache) return Test$secondtestString$Result$TypeCache;␊
        Test$secondtestString$Result$TypeCache = new Map();␊
        Test$secondtestString$Result$TypeCache.set(0, { name: 'success', customName: 'success', type: { name: 'string', typeClass: null } });␊
        Test$secondtestString$Result$TypeCache.set(1, { name: 'err1', customName: 'err1', type: { name: 'struct', typeClass: Xception } });␊
        return Test$secondtestString$Result$TypeCache;␊
      }␊
    }␊
    ␊
    `

## serverGenerator

> Snapshot 1

    `␊
    const Test$handler = Symbol('handler');␊
    ␊
    export class TestServer extends TServer {␊
      constructor(handler) {␊
        super();␊
        if (handler && typeof handler === 'object') {␊
          this[Test$handler] = handler;␊
        }␊
      }␊
    ␊
      testVoid() {␊
        if (this[Test$handler] === undefined || typeof this[Test$handler].testVoid !== 'function') {␊
          throw new Error('"Test.testVoid" is not implemented');␊
        }␊
        return this[Test$handler].testVoid.call(this[Test$handler], );␊
      }␊
    ␊
      testString(my_age) {␊
        if (this[Test$handler] === undefined || typeof this[Test$handler].testString !== 'function') {␊
          throw new Error('"Test.testString" is not implemented');␊
        }␊
        return this[Test$handler].testString.call(this[Test$handler], my_age);␊
      }␊
    ␊
      testString2(my_age, my_Name) {␊
        if (this[Test$handler] === undefined || typeof this[Test$handler].testString2 !== 'function') {␊
          throw new Error('"Test.testString2" is not implemented');␊
        }␊
        return this[Test$handler].testString2.call(this[Test$handler], my_age, my_Name);␊
      }␊
    ␊
      static get Type() {␊
        if (Test$TypeCache) return Test$TypeCache;␊
        Test$TypeCache = new Map();␊
        Test$TypeCache.set('testVoid', {␊
          customName: 'testVoid',␊
          argumentType: Test$testVoid$Args,␊
          resultType: Test$testVoid$Result,␊
          oneway: false␊
        });␊
        Test$TypeCache.set('testString', {␊
          customName: 'testString',␊
          argumentType: Test$testString$Args,␊
          resultType: Test$testString$Result,␊
          oneway: true␊
        });␊
        Test$TypeCache.set('testString2', {␊
          customName: 'testString2',␊
          argumentType: Test$testString2$Args,␊
          resultType: Test$testString2$Result,␊
          oneway: true␊
        });␊
        return Test$TypeCache;␊
      }␊
    }␊
    ;␊
    `

> Snapshot 2

    `␊
    const Test$handler = Symbol('handler');␊
    ␊
    class TestServer extends BaseServer {␊
      constructor(handler) {␊
        super();␊
        if (handler && typeof handler === 'object') {␊
          this[Test$handler] = handler;␊
        }␊
      }␊
    ␊
      testVoid() {␊
        if (this[Test$handler] === undefined || typeof this[Test$handler].testVoid !== 'function') {␊
          throw new Error('"Test.testVoid" is not implemented');␊
        }␊
        return this[Test$handler].testVoid.call(this[Test$handler], );␊
      }␊
    ␊
      testString(my_age) {␊
        if (this[Test$handler] === undefined || typeof this[Test$handler].testString !== 'function') {␊
          throw new Error('"Test.testString" is not implemented');␊
        }␊
        return this[Test$handler].testString.call(this[Test$handler], my_age);␊
      }␊
    ␊
      testString2(my_age, my_Name) {␊
        if (this[Test$handler] === undefined || typeof this[Test$handler].testString2 !== 'function') {␊
          throw new Error('"Test.testString2" is not implemented');␊
        }␊
        return this[Test$handler].testString2.call(this[Test$handler], my_age, my_Name);␊
      }␊
    ␊
      static get Type() {␊
        if (Test$TypeCache) return Test$TypeCache;␊
        Test$TypeCache = new Map();␊
        Test$TypeCache.set('testVoid', {␊
          customName: 'testVoid',␊
          argumentType: Test$testVoid$Args,␊
          resultType: Test$testVoid$Result,␊
          oneway: false␊
        });␊
        Test$TypeCache.set('testString', {␊
          customName: 'testString',␊
          argumentType: Test$testString$Args,␊
          resultType: Test$testString$Result,␊
          oneway: true␊
        });␊
        Test$TypeCache.set('testString2', {␊
          customName: 'testString2',␊
          argumentType: Test$testString2$Args,␊
          resultType: Test$testString2$Result,␊
          oneway: true␊
        });␊
        return Test$TypeCache;␊
      }␊
    }␊
    exports.TestServer = TestServer;␊
    `

## serviceGenerator

> Snapshot 1

    `␊
    let Test$blahBlah$Args$TypeCache = null;␊
    ␊
    export class Test$blahBlah$Args extends TStruct {␊
      constructor(args) {␊
        super();␊
        if (args) {␊
        }␊
      }␊
    ␊
      static get Type() {␊
        if (Test$blahBlah$Args$TypeCache) return Test$blahBlah$Args$TypeCache;␊
        Test$blahBlah$Args$TypeCache = new Map();␊
        return Test$blahBlah$Args$TypeCache;␊
      }␊
    }␊
    ␊
    ␊
    let Test$secondtestString$Args$TypeCache = null;␊
    const Test$secondtestString$Args$myThing = Symbol('myThing');␊
    ␊
    export class Test$secondtestString$Args extends TStruct {␊
      constructor(args) {␊
        super();␊
        this[Test$secondtestString$Args$myThing] = null;␊
        if (args) {␊
          this.myThing = args.myThing;␊
        }␊
      }␊
    ␊
      get myThing() { return this[Test$secondtestString$Args$myThing]; }␊
      set myThing(val) {␊
        this[Test$secondtestString$Args$myThing] = this[$convertToTypedValue](val, { name: 'string', typeClass: null }, 'myThing');␊
      }␊
    ␊
      static get Type() {␊
        if (Test$secondtestString$Args$TypeCache) return Test$secondtestString$Args$TypeCache;␊
        Test$secondtestString$Args$TypeCache = new Map();␊
        Test$secondtestString$Args$TypeCache.set(1, { name: 'my_thing', customName: 'myThing', type: { name: 'string', typeClass: null } });␊
        return Test$secondtestString$Args$TypeCache;␊
      }␊
    }␊
    ␊
    ␊
    let Test$blahBlah$Result$TypeCache = null;␊
    ␊
    export class Test$blahBlah$Result extends TStruct {␊
      constructor(args) {␊
        super();␊
        if (args) {␊
        }␊
      }␊
    ␊
      static get Type() {␊
        if (Test$blahBlah$Result$TypeCache) return Test$blahBlah$Result$TypeCache;␊
        Test$blahBlah$Result$TypeCache = new Map();␊
        return Test$blahBlah$Result$TypeCache;␊
      }␊
    }␊
    ␊
    ␊
    let Test$secondtestString$Result$TypeCache = null;␊
    const Test$secondtestString$Result$success = Symbol('success');␊
    const Test$secondtestString$Result$err1 = Symbol('err1');␊
    ␊
    export class Test$secondtestString$Result extends TStruct {␊
      constructor(args) {␊
        super();␊
        this[Test$secondtestString$Result$success] = null;␊
        this[Test$secondtestString$Result$err1] = null;␊
        if (args) {␊
          this.success = args.success;␊
          this.err1 = args.err1;␊
        }␊
      }␊
    ␊
      get success() { return this[Test$secondtestString$Result$success]; }␊
      set success(val) {␊
        this[Test$secondtestString$Result$success] = this[$convertToTypedValue](val, { name: 'string', typeClass: null }, 'success');␊
      }␊
    ␊
      get err1() { return this[Test$secondtestString$Result$err1]; }␊
      set err1(val) {␊
        this[Test$secondtestString$Result$err1] = this[$convertToTypedValue](val, { name: 'struct', typeClass: Xception }, 'err1');␊
      }␊
    ␊
      static get Type() {␊
        if (Test$secondtestString$Result$TypeCache) return Test$secondtestString$Result$TypeCache;␊
        Test$secondtestString$Result$TypeCache = new Map();␊
        Test$secondtestString$Result$TypeCache.set(0, { name: 'success', customName: 'success', type: { name: 'string', typeClass: null } });␊
        Test$secondtestString$Result$TypeCache.set(1, { name: 'err1', customName: 'err1', type: { name: 'struct', typeClass: Xception } });␊
        return Test$secondtestString$Result$TypeCache;␊
      }␊
    }␊
    ␊
    ␊
    let Test$TypeCache = null;␊
    ␊
    export class TestClient extends BaseClient {␊
      blahBlah() {␊
        const args = {  };␊
        return this[$send]('blahBlah', args);␊
      }␊
    ␊
      secondtestString(myThing) {␊
        const args = { myThing };␊
        return this[$send]('secondtestString', args);␊
      }␊
    ␊
      static get Type() {␊
        if (Test$TypeCache) return Test$TypeCache;␊
        Test$TypeCache = new Map(super.constructor.Type);␊
        Test$TypeCache.set('blahBlah', {␊
          customName: 'blahBlah',␊
          argumentType: Test$blahBlah$Args,␊
          resultType: Test$blahBlah$Result,␊
          oneway: false␊
        });␊
        Test$TypeCache.set('secondtestString', {␊
          customName: 'secondtestString',␊
          argumentType: Test$secondtestString$Args,␊
          resultType: Test$secondtestString$Result,␊
          oneway: false␊
        });␊
        return Test$TypeCache;␊
      }␊
    }␊
    ;␊
    ␊
    const Test$handler = Symbol('handler');␊
    ␊
    export class TestServer extends BaseServer {␊
      constructor(handler) {␊
        super();␊
        if (handler && typeof handler === 'object') {␊
          this[Test$handler] = handler;␊
        }␊
      }␊
    ␊
      blahBlah() {␊
        if (this[Test$handler] === undefined || typeof this[Test$handler].blahBlah !== 'function') {␊
          throw new Error('"Test.blahBlah" is not implemented');␊
        }␊
        return this[Test$handler].blahBlah.call(this[Test$handler], );␊
      }␊
    ␊
      secondtestString(myThing) {␊
        if (this[Test$handler] === undefined || typeof this[Test$handler].secondtestString !== 'function') {␊
          throw new Error('"Test.secondtestString" is not implemented');␊
        }␊
        return this[Test$handler].secondtestString.call(this[Test$handler], myThing);␊
      }␊
    ␊
      static get Type() {␊
        if (Test$TypeCache) return Test$TypeCache;␊
        Test$TypeCache = new Map();␊
        Test$TypeCache.set('blahBlah', {␊
          customName: 'blahBlah',␊
          argumentType: Test$blahBlah$Args,␊
          resultType: Test$blahBlah$Result,␊
          oneway: false␊
        });␊
        Test$TypeCache.set('secondtestString', {␊
          customName: 'secondtestString',␊
          argumentType: Test$secondtestString$Args,␊
          resultType: Test$secondtestString$Result,␊
          oneway: false␊
        });␊
        return Test$TypeCache;␊
      }␊
    }␊
    ;␊
    `

> Snapshot 2

    `␊
    let Test$blahBlah$Args$TypeCache = null;␊
    ␊
    class Test$blahBlah$Args extends TStruct {␊
      constructor(args) {␊
        super();␊
        if (args) {␊
        }␊
      }␊
    ␊
      static get Type() {␊
        if (Test$blahBlah$Args$TypeCache) return Test$blahBlah$Args$TypeCache;␊
        Test$blahBlah$Args$TypeCache = new Map();␊
        return Test$blahBlah$Args$TypeCache;␊
      }␊
    }␊
    exports.Test$blahBlah$Args = Test$blahBlah$Args;␊
    ␊
    ␊
    let Test$secondtestString$Args$TypeCache = null;␊
    const Test$secondtestString$Args$my_thing = Symbol('my_thing');␊
    ␊
    class Test$secondtestString$Args extends TStruct {␊
      constructor(args) {␊
        super();␊
        this[Test$secondtestString$Args$my_thing] = null;␊
        if (args) {␊
          this.my_thing = args.my_thing;␊
        }␊
      }␊
    ␊
      get my_thing() { return this[Test$secondtestString$Args$my_thing]; }␊
      set my_thing(val) {␊
        this[Test$secondtestString$Args$my_thing] = this[$convertToTypedValue](val, { name: 'string', typeClass: null }, 'my_thing');␊
      }␊
    ␊
      static get Type() {␊
        if (Test$secondtestString$Args$TypeCache) return Test$secondtestString$Args$TypeCache;␊
        Test$secondtestString$Args$TypeCache = new Map();␊
        Test$secondtestString$Args$TypeCache.set(1, { name: 'my_thing', customName: 'my_thing', type: { name: 'string', typeClass: null } });␊
        return Test$secondtestString$Args$TypeCache;␊
      }␊
    }␊
    exports.Test$secondtestString$Args = Test$secondtestString$Args;␊
    ␊
    ␊
    let Test$blahBlah$Result$TypeCache = null;␊
    ␊
    class Test$blahBlah$Result extends TStruct {␊
      constructor(args) {␊
        super();␊
        if (args) {␊
        }␊
      }␊
    ␊
      static get Type() {␊
        if (Test$blahBlah$Result$TypeCache) return Test$blahBlah$Result$TypeCache;␊
        Test$blahBlah$Result$TypeCache = new Map();␊
        return Test$blahBlah$Result$TypeCache;␊
      }␊
    }␊
    exports.Test$blahBlah$Result = Test$blahBlah$Result;␊
    ␊
    ␊
    let Test$secondtestString$Result$TypeCache = null;␊
    const Test$secondtestString$Result$success = Symbol('success');␊
    const Test$secondtestString$Result$err1 = Symbol('err1');␊
    ␊
    class Test$secondtestString$Result extends TStruct {␊
      constructor(args) {␊
        super();␊
        this[Test$secondtestString$Result$success] = null;␊
        this[Test$secondtestString$Result$err1] = null;␊
        if (args) {␊
          this.success = args.success;␊
          this.err1 = args.err1;␊
        }␊
      }␊
    ␊
      get success() { return this[Test$secondtestString$Result$success]; }␊
      set success(val) {␊
        this[Test$secondtestString$Result$success] = this[$convertToTypedValue](val, { name: 'string', typeClass: null }, 'success');␊
      }␊
    ␊
      get err1() { return this[Test$secondtestString$Result$err1]; }␊
      set err1(val) {␊
        this[Test$secondtestString$Result$err1] = this[$convertToTypedValue](val, { name: 'struct', typeClass: Xception }, 'err1');␊
      }␊
    ␊
      static get Type() {␊
        if (Test$secondtestString$Result$TypeCache) return Test$secondtestString$Result$TypeCache;␊
        Test$secondtestString$Result$TypeCache = new Map();␊
        Test$secondtestString$Result$TypeCache.set(0, { name: 'success', customName: 'success', type: { name: 'string', typeClass: null } });␊
        Test$secondtestString$Result$TypeCache.set(1, { name: 'err1', customName: 'err1', type: { name: 'struct', typeClass: Xception } });␊
        return Test$secondtestString$Result$TypeCache;␊
      }␊
    }␊
    exports.Test$secondtestString$Result = Test$secondtestString$Result;␊
    ␊
    ␊
    let Test$TypeCache = null;␊
    ␊
    class TestClient extends BaseClient {␊
      blahBlah() {␊
        const args = {  };␊
        return this[$send]('blahBlah', args);␊
      }␊
    ␊
      secondtestString(my_thing) {␊
        const args = { my_thing };␊
        return this[$send]('secondtestString', args);␊
      }␊
    ␊
      static get Type() {␊
        if (Test$TypeCache) return Test$TypeCache;␊
        Test$TypeCache = new Map(super.constructor.Type);␊
        Test$TypeCache.set('blahBlah', {␊
          customName: 'blahBlah',␊
          argumentType: Test$blahBlah$Args,␊
          resultType: Test$blahBlah$Result,␊
          oneway: false␊
        });␊
        Test$TypeCache.set('secondtestString', {␊
          customName: 'secondtestString',␊
          argumentType: Test$secondtestString$Args,␊
          resultType: Test$secondtestString$Result,␊
          oneway: false␊
        });␊
        return Test$TypeCache;␊
      }␊
    }␊
    exports.TestClient = TestClient;␊
    ␊
    const Test$handler = Symbol('handler');␊
    ␊
    class TestServer extends BaseServer {␊
      constructor(handler) {␊
        super();␊
        if (handler && typeof handler === 'object') {␊
          this[Test$handler] = handler;␊
        }␊
      }␊
    ␊
      blahBlah() {␊
        if (this[Test$handler] === undefined || typeof this[Test$handler].blahBlah !== 'function') {␊
          throw new Error('"Test.blahBlah" is not implemented');␊
        }␊
        return this[Test$handler].blahBlah.call(this[Test$handler], );␊
      }␊
    ␊
      secondtestString(my_thing) {␊
        if (this[Test$handler] === undefined || typeof this[Test$handler].secondtestString !== 'function') {␊
          throw new Error('"Test.secondtestString" is not implemented');␊
        }␊
        return this[Test$handler].secondtestString.call(this[Test$handler], my_thing);␊
      }␊
    ␊
      static get Type() {␊
        if (Test$TypeCache) return Test$TypeCache;␊
        Test$TypeCache = new Map();␊
        Test$TypeCache.set('blahBlah', {␊
          customName: 'blahBlah',␊
          argumentType: Test$blahBlah$Args,␊
          resultType: Test$blahBlah$Result,␊
          oneway: false␊
        });␊
        Test$TypeCache.set('secondtestString', {␊
          customName: 'secondtestString',␊
          argumentType: Test$secondtestString$Args,␊
          resultType: Test$secondtestString$Result,␊
          oneway: false␊
        });␊
        return Test$TypeCache;␊
      }␊
    }␊
    exports.TestServer = TestServer;␊
    `
