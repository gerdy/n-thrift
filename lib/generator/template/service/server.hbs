
{{#if legacy}}
const {{serviceName}}$handler = Symbol('handler');
{{/if}}

{{#if useESM}}export {{/if}}class {{serviceName}}Server extends {{extendServiceName}} {
  constructor({{#if legacy}}handler{{/if}}) {
    super({{legacy}});
    {{#if legacy}}
    this[{{../serviceName}}$handler] = handler || {};
    {{/if}}
  }
  {{#each functions}}

  {{name}}({{#forEach args}}{{customName}}{{#unless isLast}}, {{/unless}}{{/forEach}}) {
    {{#unless ../legacy}}
    throw new Error('"{{../serviceName}}.{{name}}" is not implemented');
    {{else}}
    if (typeof this[{{../serviceName}}$handler].{{name}} !== 'function') {
      throw new Error('"{{../serviceName}}.{{name}}" is not implemented');
    }
    return new Promise((resolve, reject) => {
      this[{{../serviceName}}$handler].{{name}}({{#forEach args}}{{customName}}, {{/forEach}}(error, result) => {
        if (error) return reject(error);
        return resolve(result);
      });
    });
    {{/unless}}
  }
  {{/each}}

  static get Types() {
    if({{serviceName}}$TypeCache) return {{serviceName}}$TypeCache;
    {{serviceName}}$TypeCache = new Map();
    {{#each functions}}
    {{../serviceName}}$TypeCache.set('{{name}}', {
      customName: {{name}},
      argumentType: {{../serviceName}}${{name}}$Args,
      resultType: {{../serviceName}}${{name}}$Result,
      oneway: {{oneway}}
    });
    {{/each}}
    return {{serviceName}}$TypeCache;
  }
}
{{#unless useESM}}exports.{{serviceName}}Server = {{serviceName}}Server{{/unless}}
{{#if legacy}}
  {{#if useESM}} 
export const Processor = {{serviceName}}Server;
  {{else}}
exports.Processor = {{serviceName}}Server;
  {{/if}}
{{/if}}
